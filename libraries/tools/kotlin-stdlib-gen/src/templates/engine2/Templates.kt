package templates2

import generators.COMMON_AUTOGENERATED_WARNING
import templates.*
import templates.Family.*
import templates.Family.Collections
import java.io.File
import java.io.FileWriter
import java.util.*
import kotlin.coroutines.experimental.buildSequence
import templates.GenericFunction.TypeParameter
import templates.PrimitiveType.Companion.maxByCapacity
import java.io.StringReader

@DslMarker
annotation class TemplateDsl

enum class MemberKind(val keyword: String) {
    Function("fun"),
    Value("val"),
    Variable("var")
}

typealias MemberSignatureDraft = (MemberBuilder) -> Unit

private fun def(signature: String, memberKind: MemberKind): MemberSignatureDraft = { m ->
    m.signature = signature
    m.kind = memberKind
}

fun fn(defaultSignature: String): MemberSignatureDraft = def(defaultSignature, MemberKind.Function)

fun fn(defaultSignature: String, setup: FamilyPrimitiveMemberDsl.() -> Unit): MemberTemplate =
        FamilyPrimitiveMemberDsl().apply {
            externalBuilderFunction = fn(defaultSignature)
            setup()
        }

fun MemberSignatureDraft.byTwoPrimitives(setup: PairPrimitiveMemberDsl.() -> Unit): MemberTemplate =
        PairPrimitiveMemberDsl().apply {
            externalBuilderFunction = this@byTwoPrimitives
            setup()
        }

fun pval(name: String, setup: FamilyPrimitiveMemberDsl.() -> Unit): MemberTemplate =
        FamilyPrimitiveMemberDsl().apply {
            externalBuilderFunction = def(name, MemberKind.Value)
            setup()
        }

fun pvar(name: String, setup: FamilyPrimitiveMemberDsl.() -> Unit): MemberTemplate =
        FamilyPrimitiveMemberDsl().apply {
            externalBuilderFunction = def(name, MemberKind.Variable)
            setup()
        }


interface MemberTemplate {
    fun instantiate(): Sequence<MemberBuilder>
}

abstract class GenericMemberDsl<TParam> : MemberTemplate {
    var externalBuilderFunction: ((MemberBuilder) -> Unit)? = null

    protected open fun specificBuilderDefaults(memberBuilder: MemberBuilder, p: TParam) {
    }

    private var targetPlatforms = setOf(*Platform.values())
    fun platforms(vararg platforms: Platform) {
        targetPlatforms = setOf(*platforms)
    }


    private var filterPredicate: ((Family, TParam) -> Boolean)? = null
    /** sets the filter predicate that is applied to produced sequence of variations */
    fun filter(predicate: (Family, TParam) -> Boolean) {
        this.filterPredicate = predicate
    }

    private lateinit var builderFunction: MemberBuilder.(TParam) -> Unit
    fun builder(b: MemberBuilder.(TParam) -> Unit) {
        this.builderFunction = b
    }



    /** Provides the sequence of member variation parameters */
    protected abstract fun parametrize(): Sequence<Pair<Family, TParam>>

    private fun Sequence<Pair<Family, TParam>>.applyFilter() =
            filterPredicate?.let { predicate ->
                filter { (family, p) -> predicate(family, p) }
            } ?: this


    override fun instantiate(): Sequence<MemberBuilder> {
        val specificPlatforms by lazy { targetPlatforms - Platform.Common }

        fun platformMemberBuilders(family: Family, p: TParam) =
                if (Platform.Common in targetPlatforms) {
                    val commonMemberBuilder = createMemberBuilder(Platform.Common, family, p)
                    mutableListOf(commonMemberBuilder).also { builders ->
                        if (commonMemberBuilder.hasPlatformSpecializations) {
                            specificPlatforms.mapTo(builders) {
                                createMemberBuilder(it, family, p)
                            }
                        }
                    }
                } else {
                    targetPlatforms.map { createMemberBuilder(it, family, p) }
                }

        return parametrize()
                .applyFilter()
                .map { (family, p) -> platformMemberBuilders(family, p) }
                .flatten()
    }

    private fun createMemberBuilder(platform: Platform, family: Family, p: TParam): MemberBuilder {
        return MemberBuilder(targetPlatforms, platform, family).also { builder ->
            externalBuilderFunction?.invoke(builder)
            specificBuilderDefaults(builder, p)
            builderFunction(builder, p)
        }
    }

}

private fun defaultPrimitives(f: Family): Set<PrimitiveType> =
        if (f.isPrimitiveSpecialization) PrimitiveType.defaultPrimitives else emptySet()

@TemplateDsl
class FamilyPrimitiveMemberDsl : GenericMemberDsl<PrimitiveType?>() {

    private val familyPrimitives = mutableMapOf<Family, Set<PrimitiveType>>()

    fun include(vararg fs: Family) {
        for (f in fs) familyPrimitives[f] = defaultPrimitives(f)
    }

    fun include(fs: Collection<Family>) {
        for (f in fs) familyPrimitives[f] = defaultPrimitives(f)
    }

    fun includeDefault() {
        include(Family.defaultFamilies)
    }

    fun include(f: Family, primitives: Set<PrimitiveType>) {
        familyPrimitives[f] = primitives
    }

    fun exclude(vararg ps: PrimitiveType) {
        val toExclude = ps.toSet()
        for (e in familyPrimitives) {
            e.setValue(e.value - toExclude)
        }
    }

    override fun parametrize(): Sequence<Pair<Family, PrimitiveType?>> = buildSequence {
        for ((family, primitives) in familyPrimitives) {
            if (primitives.isEmpty())
                yield(family to null)
            else
                yieldAll(primitives.map { family to it })
        }
    }

    override fun specificBuilderDefaults(memberBuilder: MemberBuilder, p: PrimitiveType?) {
        memberBuilder.primitive = p
    }
}

@TemplateDsl
class PairPrimitiveMemberDsl : GenericMemberDsl<Pair<PrimitiveType, PrimitiveType>>() {

    private val familyPrimitives = mutableMapOf<Family, Set<Pair<PrimitiveType, PrimitiveType>>>()

    fun include(f: Family, primitives: Collection<Pair<PrimitiveType, PrimitiveType>>) {
        familyPrimitives[f] = primitives.toSet()
    }

    override fun parametrize(): Sequence<Pair<Family, Pair<PrimitiveType, PrimitiveType>>> {
        return familyPrimitives
                .flatMap { e -> e.value.map { e.key to it } }
                .asSequence()
    }

    override fun specificBuilderDefaults(memberBuilder: MemberBuilder, p: Pair<PrimitiveType, PrimitiveType>) {
        memberBuilder.primitive = p.first
    }
}




@TemplateDsl
class MemberBuilder(
        val allowedPlatforms: Set<Platform>,
        val platform: Platform,
        var family: Family,
        var sourceFile: SourceFile = getDefaultSourceFile(family),
        var primitive: PrimitiveType? = null
) {
    lateinit var kind: MemberKind    // fun/val/var
    lateinit var signature: String   // name and params

    val f get() = family

    var hasPlatformSpecializations: Boolean = false
        private set

    var doc: String? = null; private set

    val sequenceClassification = mutableListOf<SequenceClass>()
    var deprecate: Deprecation? = null; private set
    var since: String? = null; private set
    var platformName: String? = null; private set

    var visibility: String? = null; private set
    var external: Boolean = false; private set
    var inline: Inline = Inline.No; private set
    var infix: Boolean = false; private set
    var operator: Boolean = false; private set
    val typeParams = mutableListOf<String>()
    var customReceiver: String? = null; private set
    var receiverAsterisk: Boolean = false; private set
    var toNullableT: Boolean = false; private set

    var returns: String? = null; private set
    var body: String? = null; private set
    val annotations: MutableList<String> = mutableListOf()

    fun sourceFile(file: SourceFile) { sourceFile = file }

    fun deprecate(value: Deprecation) { deprecate = value }
    fun deprecate(value: String) { deprecate = Deprecation(value)}
    fun platformName(name: String) { platformName = name }

    fun visibility(value: String) { visibility = value }
    fun external(value: Boolean = true) { external = value }
    fun operator(value: Boolean = true) { operator = value }
    fun infix(value: Boolean = true) { infix = value }
    fun inline(value: Inline = Inline.Yes, suppressWarning: Boolean = false) {
        inline = value
        if (suppressWarning) {
            require(value == Inline.Yes)
            annotations += """@Suppress("NOTHING_TO_INLINE")"""
        }
    }
    fun inlineOnly() { inline = Inline.Only }

    fun receiver(value: String) { customReceiver = value }
    fun signature(value: String) { signature = value }
    fun returns(type: String) { returns = type }

    fun typeParam(typeParameterName: String) {
        typeParams += typeParameterName
    }

    fun sequenceClassification(vararg sequenceClass: SequenceClass) {
        sequenceClassification += sequenceClass
    }

    fun doc(valueBuilder: DocExtensions.() -> String) {
        doc = valueBuilder(DocExtensions)
    }

    fun body(valueBuilder: () -> String) {
        body = valueBuilder()
    }


    fun on(platform: Platform, action: () -> Unit) {
        require(platform in allowedPlatforms) { "Platform $platform is not in the list of allowed platforms $allowedPlatforms" }
        if (this.platform == platform)
            action()
        else {
            hasPlatformSpecializations = true
        }
    }

    fun specialFor(f: Family, action: () -> Unit) {
        if (family == f)
            action()
    }


    fun build(builder: Appendable) {
        val headerOnly: Boolean = platform == Platform.Common && hasPlatformSpecializations
        val isImpl: Boolean = platform != Platform.Common && Platform.Common in allowedPlatforms

        val returnType = returns ?: throw RuntimeException("No return type specified for $signature")


        fun renderType(expression: String, receiver: String, self: String): String {
            val t = StringTokenizer(expression, " \t\n,:()<>?.", true)
            val answer = StringBuilder()

            while (t.hasMoreTokens()) {
                val token = t.nextToken()
                answer.append(when (token) {
                    "RECEIVER" -> receiver
                    "SELF" -> self
                    "PRIMITIVE" -> primitive?.name ?: token
                    "SUM" -> {
                        when (primitive) {
                            PrimitiveType.Byte, PrimitiveType.Short, PrimitiveType.Char -> "Int"
                            else -> primitive
                        }
                    }
                    "ZERO" -> when (primitive) {
                        PrimitiveType.Double -> "0.0"
                        PrimitiveType.Float -> "0.0f"
                        PrimitiveType.Long -> "0L"
                        else -> "0"
                    }
                    "ONE" -> when (primitive) {
                        PrimitiveType.Double -> "1.0"
                        PrimitiveType.Float -> "1.0f"
                        PrimitiveType.Long -> "1L"
                        else -> "1"
                    }
                    "-ONE" -> when (primitive) {
                        PrimitiveType.Double -> "-1.0"
                        PrimitiveType.Float -> "-1.0f"
                        PrimitiveType.Long -> "-1L"
                        else -> "-1"
                    }
                    "TCollection" -> {
                        when (family) {
                            CharSequences, Strings -> "Appendable"
                            else -> renderType("MutableCollection<in T>", receiver, self)
                        }
                    }
                    "T" -> {
                        when (family) {
                            Generic -> "T"
                            CharSequences, Strings -> "Char"
                            Maps -> "Map.Entry<K, V>"
                            else -> primitive?.name ?: token
                        }
                    }
                    "TRange" -> {
                        when (family) {
                            Generic -> "Range<T>"
                            else -> primitive!!.name + "Range"
                        }
                    }
                    "TProgression" -> {
                        when (family) {
                            Generic -> "Progression<out T>"
                            else -> primitive!!.name + "Progression"
                        }
                    }
                    else -> token
                })
            }

            return answer.toString()
        }

        val isAsteriskOrT = if (receiverAsterisk) "*" else "T"
        val self = (when (family) {
            Iterables -> "Iterable<$isAsteriskOrT>"
            Collections -> "Collection<$isAsteriskOrT>"
            Lists -> "List<$isAsteriskOrT>"
            Maps -> "Map<out K, V>"
            Sets -> "Set<$isAsteriskOrT>"
            Sequences -> "Sequence<$isAsteriskOrT>"
            InvariantArraysOfObjects -> "Array<T>"
            ArraysOfObjects -> "Array<${isAsteriskOrT.replace("T", "out T")}>"
            Strings -> "String"
            CharSequences -> "CharSequence"
            Ranges -> "ClosedRange<$isAsteriskOrT>"
            ArraysOfPrimitives -> primitive?.let { it.name + "Array" } ?: throw IllegalArgumentException("Primitive array should specify primitive type")
            RangesOfPrimitives -> primitive?.let { it.name + "Range" } ?: throw IllegalArgumentException("Primitive range should specify primitive type")
            ProgressionsOfPrimitives -> primitive?.let { it.name + "Progression" } ?: throw IllegalArgumentException("Primitive progression should specify primitive type")
            Primitives -> primitive?.let { it.name } ?: throw IllegalArgumentException("Primitive should specify primitive type")
            Generic -> "T"
        })

        val receiver = (customReceiver ?: self).let { renderType(it, it, self) }

        fun String.renderType(): String = renderType(this, receiver, self)

        fun effectiveTypeParams(): List<TypeParameter> {
            val parameters = typeParams.mapTo(mutableListOf()) { parseTypeParameter(it.renderType()) }

            if (family == Generic) {
                if (parameters.none { it.name == "T" })
                    parameters.add(TypeParameter("T"))
                return parameters
            } else if (primitive == null && family != Strings && family != CharSequences) {
                val mentionedTypes = parseTypeRef(receiver).mentionedTypes() + parameters.flatMap { it.mentionedTypeRefs() }
                val implicitTypeParameters = mentionedTypes.filter { it.name.all(Char::isUpperCase) }
                for (implicit in implicitTypeParameters.reversed()) {
                    if (implicit.name != "*" && parameters.none { it.name == implicit.name }) {
                        parameters.add(0, TypeParameter(implicit.name))
                    }
                }

                return parameters
            } else {
                // substituted T is no longer a parameter
                val renderedT = "T".renderType()
                return parameters.filterNot { it.name == renderedT }
            }
        }


        doc?.let { methodDoc ->
            builder.append("/**\n")
            StringReader(methodDoc.trim()).forEachLine { line ->
                builder.append(" * ").append(line.trim()).append("\n")
            }
            if (family == Sequences && sequenceClassification.isNotEmpty()) {
                builder.append(" *\n")
                builder.append(" * The operation is ${sequenceClassification.joinToString(" and ") { "_${it}_" }}.\n")
            }
            builder.append(" */\n")
        }



        deprecate?.let { deprecated ->
            val args = listOfNotNull(
                    "\"${deprecated.message}\"",
                    deprecated.replaceWith?.let { "ReplaceWith(\"$it\")" },
                    deprecated.level.let { if (it != DeprecationLevel.WARNING) "level = DeprecationLevel.$it" else null }
            )
            builder.append("@Deprecated(${args.joinToString(", ")})\n")
        }

        if (!f.isPrimitiveSpecialization && primitive != null) {
            platformName
                    ?.replace("<T>", primitive!!.name)
                    ?.let { platformName -> builder.append("@kotlin.jvm.JvmName(\"${platformName}\")\n") }
        }

        since?.let { since ->
            builder.append("@SinceKotlin(\"$since\")\n")
        }

        annotations.forEach { builder.append(it.trimIndent()).append('\n') }

        if (inline == Inline.Only) {
            builder.append("@kotlin.internal.InlineOnly").append('\n')
        }

        builder.append(visibility ?: "public").append(' ')
        if (headerOnly) {
            builder.append("header ")
        }
        if (isImpl) {
            builder.append("impl ")
        }
        if (external)
            builder.append("external ")
        if (inline.isInline())
            builder.append("inline ")

        if (infix)
            builder.append("infix ")
        if (operator)
            builder.append("operator ")


        builder.append("${kind.keyword} ")

        val types = effectiveTypeParams()
        if (!types.isEmpty()) {
            builder.append(types.joinToString(separator = ", ", prefix = "<", postfix = "> ", transform = { it.original }))
        }

        val receiverType = (if (toNullableT) receiver.replace("T>", "T?>") else receiver).renderType()

        builder.append(receiverType)
        if (receiverType.isNotEmpty()) builder.append('.')
        builder.append("${signature.renderType()}: ${returnType.renderType()}")

        if (headerOnly) {
            builder.append("\n\n")
            return
        }

        if (kind == MemberKind.Function) builder.append(" {")

        val body = (body ?:
                deprecate?.replaceWith?.let { "return $it" } ?:
                throw RuntimeException("No body specified for $signature for ${family to primitive}")
                ).trim('\n')
        val indent: Int = body.takeWhile { it == ' ' }.length

        builder.append('\n')
        body.lineSequence().forEach {
            var count = indent
            val line = it.dropWhile { count-- > 0 && it == ' ' }.renderType()
            if (!line.isEmpty()) {
                builder.append("    ").append(line)
                builder.append("\n")
            }
        }
        if (kind == MemberKind.Function) builder.append("}\n")
        builder.append("\n")
    }

}




val rangePrimitives = listOf(PrimitiveType.Int, PrimitiveType.Long, PrimitiveType.Char)
fun rangeElementType(fromType: PrimitiveType, toType: PrimitiveType)
        = maxByCapacity(fromType, toType).let { if (it == PrimitiveType.Char) it else maxByCapacity(it, PrimitiveType.Int) }

fun <T> Collection<T>.permutations(): List<Pair<T, T>> = flatMap { a -> map { b -> a to b } }
val numericPrimitives = PrimitiveType.numericPrimitives
val numericPermutations = numericPrimitives.permutations()
val primitivePermutations = numericPermutations + (PrimitiveType.Char to PrimitiveType.Char)
val integralPermutations = primitivePermutations.filter { it.first.isIntegral() && it.second.isIntegral() }


val f_downTo = fn("downTo(to: Primitive)").byTwoPrimitives {
    include(Primitives, integralPermutations)

    builder { (fromType, toType) ->
        sourceFile(SourceFile.Ranges)

        val elementType = rangeElementType(fromType, toType)
        val progressionType = elementType.name + "Progression"

        infix()
        signature("downTo(to: $toType)")
        returns(progressionType)

        doc {
            """
            Returns a progression from this value down to the specified [to] value with the step -1.

            The [to] value has to be less than this value.
            """
        }


        val fromExpr = if (elementType == fromType) "this" else "this.to$elementType()"
        val toExpr = if (elementType == toType) "to" else "to.to$elementType()"
        val incrementExpr = when (elementType) {
            PrimitiveType.Long -> "-1L"
            PrimitiveType.Float -> "-1.0F"
            PrimitiveType.Double -> "-1.0"
            else -> "-1"
        }

        body {
            "return $progressionType.fromClosedRange($fromExpr, $toExpr, $incrementExpr)"
        }
    }
}

val f_sort_range = fn("sort(fromIndex: Int = 0, toIndex: Int = size)") {
    platforms(Platform.JVM)
    include(ArraysOfObjects, ArraysOfPrimitives)
    exclude(PrimitiveType.Boolean)

    builder {
        doc { "Sorts a range in the array in-place." }
        returns("Unit")
        body {  "java.util.Arrays.sort(this, fromIndex, toIndex)" }
    }
}

val f_copyOf = fn("copyOf()") {
    include(InvariantArraysOfObjects)
    include(ArraysOfPrimitives, PrimitiveType.defaultPrimitives)
    builder { primitive ->

        doc { "Returns new array which is a copy of the original array." }
        returns("SELF")
        on(Platform.JVM) {
            inlineOnly()
            body { "return java.util.Arrays.copyOf(this, size)" }
        }
        on(Platform.JS) {
            specialFor(InvariantArraysOfObjects) { family = ArraysOfObjects }
            when (primitive) {
                null ->
                    body { "return this.asDynamic().slice()" }
                PrimitiveType.Char, PrimitiveType.Boolean, PrimitiveType.Long ->
                    body { "return withType(\"${primitive}Array\", this.asDynamic().slice())" }
                else -> {
                    inline(suppressWarning = true)
                    body { "return this.asDynamic().slice()" }
                }
            }
        }

    }
}

val f_plusElementOperator = fn("plus(element: T)") {
    include(InvariantArraysOfObjects, ArraysOfPrimitives)

    builder { primitive ->
        doc { "Returns an array containing all elements of the original array and then the given [element]." }
        operator()
        returns("SELF")

        on(Platform.JVM) {
            body {
                """
                        val index = size
                        val result = java.util.Arrays.copyOf(this, index + 1)
                        result[index] = element
                        return result
                        """
            }
        }

        on(Platform.JS) {
            inline(suppressWarning = true)
            specialFor(InvariantArraysOfObjects) {
                family = ArraysOfObjects
                returns("Array<T>")
            }

            body {
                if (primitive == null)
                    "return this.asDynamic().concat(arrayOf(element))"
                else
                    "return plus(${primitive.name.toLowerCase()}ArrayOf(element))"
            }
        }
    }
}



data class PlatformSourceFile(
        val platform: Platform,
        val sourceFile: SourceFile
)

private fun getDefaultSourceFile(f: Family): SourceFile = when (f) {
    Iterables, Collections, Lists -> SourceFile.Collections
    Sequences -> SourceFile.Sequences
    Sets -> SourceFile.Sets
    Ranges, RangesOfPrimitives, ProgressionsOfPrimitives -> SourceFile.Ranges
    ArraysOfObjects, InvariantArraysOfObjects, ArraysOfPrimitives -> SourceFile.Arrays
    Maps -> SourceFile.Maps
    Strings -> SourceFile.Strings
    CharSequences -> SourceFile.Strings
    Primitives, Generic -> SourceFile.Misc
}


fun Sequence<MemberTemplate>.groupByFileAndWrite(
        fileNameBuilder: (PlatformSourceFile) -> File
) {
    val groupedMembers = map { it.instantiate() }.flatten().groupBy {
        PlatformSourceFile(it.platform, it.sourceFile)
    }

    for ((psf, members) in groupedMembers) {
        val file = fileNameBuilder(psf)
        members.writeTo(file, psf)
    }
}

fun List<MemberBuilder>.writeTo(file: File, platformSource: PlatformSourceFile) {
    val (platform, sourceFile) = platformSource
    println("Generating file: $file")
    file.parentFile.mkdirs()
    FileWriter(file).use { writer ->
        if (sourceFile.multifile) {
            writer.appendln("@file:kotlin.jvm.JvmMultifileClass")
        }

        writer.appendln("@file:kotlin.jvm.JvmName(\"${sourceFile.jvmClassName}\")")
        if (platform == Platform.JVM)
            writer.appendln("@file:kotlin.jvm.JvmVersion")
        writer.appendln()

        writer.append("package ${sourceFile.packageName ?: "kotlin"}\n\n")
        writer.append("$COMMON_AUTOGENERATED_WARNING\n\n")
        if (platform == Platform.JS) {
            writer.appendln("import kotlin.js.*")
            if (sourceFile == SourceFile.Arrays) {
                writer.appendln("import primitiveArrayConcat")
                writer.appendln("import withType")
            }
        }
        writer.appendln("import kotlin.comparisons.*")

        if (platform != Platform.Common && sourceFile == SourceFile.Sequences) {
            writer.appendln("import kotlin.coroutines.experimental.*")
        }

        writer.appendln()

        for (f in this) {
            f.build(writer)
        }
    }
}


/*
val t_copyOfResized = MemberTemplatePar<DefaultParametrization>().apply {
    parametrization = buildSequence<DefaultParametrization> {
        val allPlatforms = setOf(*Platform.values())
        yield(DefaultParametrization(InvariantArraysOfObjects, platforms = allPlatforms))
        yieldAll(PrimitiveType.defaultPrimitives.map { DefaultParametrization(ArraysOfPrimitives, it, platforms = allPlatforms) })
    }
    builder = { p, platform, builder ->
        builder.family = if (p.family == InvariantArraysOfObjects && platform == Platform.JS)
            ArraysOfObjects else p.family

        if (platform == Platform.JVM)
            builder.inline = Inline.Only

        builder.doc = "Returns new array which is a copy of the original array."
        builder.returns = "SELF"
        if (platform == Platform.JS && p.family == ArraysOfObjects)
            builder.returns = "Array<T>"

        if (platform == Platform.JVM) {
            builder.body = "return java.util.Arrays.copyOf(this, size)"
        } else if (platform == Platform.JS) {
            when (p.primitive) {
                null ->
                    builder.body = "return this.asDynamic().slice()"
                PrimitiveType.Char, PrimitiveType.Boolean, PrimitiveType.Long ->
                    builder.body = "return withType(\"${p.primitive}Array\", this.asDynamic().slice())"
                else -> {
                    builder.annotations += """@Suppress("NOTHING_TO_INLINE")"""
                    builder.inline = Inline.Yes
                    builder.body = "return this.asDynamic().slice()"
                }
            }
        }


    }
}
interface MemberTemplate {

    fun instantiate(): Sequence<MemberInstance>
}

class MemberTemplatePar<TParametrization : Parametrization> : MemberTemplate {

    val keyword: String = "fun"

    lateinit var parametrization: Sequence<TParametrization>
    lateinit var builder: (TParametrization, Platform, MemberBuilder) -> Unit

    override fun instantiate(): Sequence<MemberInstance> =
            parametrization.flatMap {
                it.platforms.asSequence().map { p ->
                    val memberBuilder = MemberBuilder().apply {
                        builder(it, p, this)
                    }
                    MemberInstance(memberBuilder::build, PlatformSourceFile(p, memberBuilder.sourceFile))
                }
            }

}
*/



/*

class MemberInstance(
        val textBuilder: (Appendable) -> Unit,
        val platformSourceFile: PlatformSourceFile)
*/


fun main(args: Array<String>) {
    val fns = sequenceOf(f_copyOf, f_sort_range, f_downTo, f_plusElementOperator)


    fns.groupByFileAndWrite { (platform, source) ->
        File("build/out/$platform/$source.kt")
    }
}